<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html" charset="utf-8" />
		<title>Learn JAVA</title>
		<link rel='stylesheet' href='css/bootstrap.min.css' type='text/css' media='all'>		
		<script src="js/bootstrap.js"></script>
		<script src="js/jquery.min.js"></script>
		<script src="js/bootstrap.min.js"></script>		
		<style CSS>
			body {
				padding-top:50px;
			}

			#masthead { 
				min-height:250px;
			}

			#masthead h1 {
				font-size: 30px;
				line-height: 1;
				padding-top:20px;
			}

			#masthead .well {
				margin-top:8%;
			}

			@media screen and (min-width: 768px) {
				#masthead h1 {
					font-size: 50px;
				}
			}

			.navbar-bright {
				background-color:#111155;
				color:#fff;
			}

			.affix-top,.affix{
				position: static;
			}

			@media (min-width: 979px) {
				#sidebar.affix-top {
					position: static;
					margin-top:30px;
					width:228px;
				}
  
				#sidebar.affix {
					position: fixed;
					top:70px;
					width:228px;
				}
			}

			#sidebar li.active {
				border:0 #eee solid;
				border-right-width:5px;
			}
		</style>
		
	</head>
	<body>	
		<nav class="navbar navbar-inverse navbar-default navbar-fixed-top" role="banner">
		<div class="container">
			<div class="navbar-header">
				<button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-collapse">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a href="#" class="navbar-brand">Java Learn</a>
			</div>
			<nav class="collapse navbar-collapse" role="navigation">
				<ul class="nav navbar-nav">
					<li>
						<a href="index.html">Теория</a>
					</li>
					<li>
						<a href="test.html">Тест</a>
					</li>					
				</ul>
			</nav>
		</div>
		</nav>

		<div id="masthead">  
		<div class="container">
			<div class="row">
				<div class="col-md-7">
					<h1>Основы программирования на Java
						<p class="lead">  </p>
					</h1>
				</div>
				<div class="col-md-5">
					<div class="well well-lg"> 
					<div class="row">						
						<div class="col-sm-12">
							<center>Теоретический раздел</center>
						</div>
					</div>
					</div>
				</div>
			</div> 
		</div><!--/container-->
		</div><!--/masthead-->

		<!--main-->
		<div class="container">
			<div class="row">
			<!--left-->
				<div class="col-md-3" id="leftCol">
					<ul class="nav nav-stacked" id="sidebar">
						<li><a href="#sec0">Введение</a></li>
						<li><a href="#sec1">Основные понятия</a></li>
						<li><a href="#sec2">Типы</a></li>
						<li><a href="#sec3">Массивы</a></li>
						<li><a href="#sec4">Операторы</a></li>
						<li><a href="#sec5">Управление выполнением программы</a></li>
						<li><a href="#sec6">Циклы</a></li>
						<li><a href="#sec7">Объектно-ориентированное программирование на Java</a></li>
					</ul>
				</div><!--/left-->
      
			<!--right-->
				<div class="col-md-9">
				<h2 id="sec0">Введение</h2>
				<p>
					Java - это язык программирования для Internet. Java - это язык для создания безопасных, переносимых,
					надежных, объектно-ориентированных интерактивных программ с параллельно выполняющимися подпроцессами.
				</p>
				
				<hr>
				<p>
					Создание языка Java — это действительно один из самых значительных шагов вперед в области разработки сред
					программирования за последние 20 лет. Язык HTML (Hypertext Markup Language — язык разметки гипертекста) был 
					необходим для статического размещения страниц во «Всемирной паутине» WWW (World Wide Web). Язык Java потребовался
					для качественного скачка в создании интерактивных продуктов для сети Internet.
					Три ключевых элемента объединились в технологии языка Java и сделали ее в корне отличной от всего, существующего на сегодняшний день:
				</p>
				<p>
					-  Java предоставляет для широкого использования свои аплеты — небольшие, надежные, динамичные, не зависящие от платформы активные сетевые
					приложения, встраиваемые в страницы Web. Аплеты Java могут настраиваться и распространяться потребителям с такой же легкостью, как
					любые документы HTML.
				</p>
				<p>	
					-  Java предоставляет мощные объектно-ориентированные принципы разработки приложений, сочетая простой и знакомый синтаксис с надежной
					и удобной в работе средой разработки. Это позволяет широкому кругу программистов быстро создавать новые программы и новые аплеты.
				</p>
				<p>
					-  Java предоставляет программисту богатый набор классов объектов для ясного абстрагирования многих системных функций, используемых
					при работе с окнами, сетью и для ввода-вывода. Ключевая черта этих классов заключается в том, что они обеспечивают создание независимых
					от используемой платформы абстракций для широкого спектра системных интерфейсов.
				</p>
				<p>
					Программирование на Java очень привлекательно. Можно очень быстро начать писать программы, получая удовлетворительные результаты. Это 
					пособие дает основы объектно-ориентированного программирования, необходимого для успешной работы на Java. Кроме этого, пособие знакомит с
					базовыми конструкциями этого языка.
				</p>
        
				<h2 id="sec1">Основные понятия</h2>
				<p>
					<h5>1. ПЕРЕМЕННЫЕ</h5>
				</p>
				<p>
					Переменная - это основной элемент хранения информации в Java- программе. Переменная характеризуется комбинацией идентификатора, 
					типа и области действия. В зависимости от того, где объявлена переменная, она может быть локальной, например, для кода внутри метода,
					либо это может быть переменная экземпляра класса, доступная всем методам данного класса. Локальные области действия объявляются с помощью фигурных скобок.
				</p>
				<p>
					<h5>1.1. Объявление переменных</h5>
					Все переменные должны быть объявлены до первого их использования в программе. 					
					Тип — это либо один из встроенных типов, либо имя класса или интерфейса. Ниже приведено несколько примеров объявления переменных 
					различных типов. Обратите внимание на то, что некоторые примеры включают в себя инициализацию начального значения. Переменные, для 
					которых начальные значения не указаны, автоматически инициализируются нулем.
				</p>
				<p>
				<div class="row">
					<div class="col-md-12">
						<div class="panel panel-default">
						<div class="panel-heading"><h4>Основная форма объявления переменной такова:</h4></div>
						<div class="panel-body">тип идентификатор [ = значение] [, идентификатор [ = значение ]...];</div>
						</div>
					</div>					 
				</div>
				</p>
				<p><b>Таблица 1.1. Объявление переменных различных типов</b></p>
				<div class="table-responsive">
					<table class="table table-condensed table-hover">
						<thead>
						<tr>
							<th>№</th>
							<th>Тип</th>
							<th>Вид переменной</th>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>1</td>
							<td>int а, b, с;</td>
							<td>Объявляет три целых переменных а, b, с</td>
						</tr>
						<tr>
							<td>2</td>
							<td>int d = 3, е, f = 5;</td>
							<td>Объявляет еще три целых переменных, инициализирует d и f</td>
						</tr>
						<tr>
							<td>3</td>
							<td>byte z = 22;</td>
							<td>Объявляет переменную z типа byte и инициализирует ее</td>
						</tr>
						<tr>
							<td>4</td>
							<td>double pi = 3.14159;</td>
							<td>Объявляет переменную pi типа double и инициализирует ее числом пи</td>
						</tr>
						<tr>
							<td>5</td>
							<td>char x = 'x';</td>
							<td>Символьная переменная х получает значение 'х'</td>
						</tr>
						</tbody>
					</table> 
				</div>
				<p>
					Идентификатор – это наименование переменной. В качестве идентификатора может использоваться любая последовательность 
					строчных и прописных букв, цифр и символов _ (подчеркивание) и $ (доллар). Идентификаторы не должны начинаться с цифры.
				</p>
				<p>
					Значение - это любой литерал или выражение, результатом которого является значение того же (или совместимого с указанным
					в объявлении переменной) типа. В приведенном ниже примере создаются три переменные, соответствующие сторонам прямоугольного 
					треугольника, а затем с помощью теоремы Пифагора вычисляется длина гипотенузы, в данном случае числа 5, величины гипотенузы
					классического прямоугольного треугольника со сторонами 3-4-5.
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>class Variables {<br> 
								public static void main (String args []){ <br> 
									double a = 3; <br> 
									double b = 4; <br> 
									double c; <br> 
									с = Math.sqrt (a* a + b* b); <br> 
									System.out.println ("c = "+ c); <br> 
								
								}</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h5>1.2. Область видимости переменной</h5>
				</p>
				<p>
					Блоки составных операторов в Java отмечаются парой фигурных скобок {}. Переменные в Java начинают действовать с того места
					в программе, где они объявлены до конца содержащего их блока. Блоки могут быть вложены друг в друга, и у каждого может быть
					свой собственный набор локальных переменных.
				</p>

				<hr>
        
				<h2 id="sec2">Типы</h2>
				<p>
					Тип - это классификация, основанная на содержимом и индивидуальности. В программировании тип определяет свойства выражения
					или переменной таким образом, что можно предсказать ее поведение.
				</p>				
					<h5>2.1. Простые типы</h5>
				
				<p>		
					Простые типы в Java не являются объектно-ориентированными, они аналогичны простым типам большинства традиционных языков
					программирования. Простые типы служат для представления элементарных, содержащих единственные значения сущностей - целых
					и вещественных чисел, символов и логических значений. В Java имеется восемь простых типов: byte, short, int, long, char, float,
					double и boolean. Их можно разделить на четыре группы:	
				<p>		
					1. Целые. К ним относятся типы byte, short, int и long. Эти типы предназначены дляцелых чисел со знаком.
				</p>
				<p>	
					2. Типы с плавающей точкой — float и double. Они служат для представления чисел, имеющих дробную часть.
				</p>	
				<p>	
					3. Символьный тип char. Этот тип предназначен для представления элементов из таблицы символов, например, букв или цифр.
				</p>
				<p>	
					4. Логический тип boolean. Это специальный тип, используемый для представления логических величин.
				</p>	
					В Java в отличие от некоторых других языков отсутствует автоматическое приведение типов. Несовпадение типов приводит к сообщению 
					об ошибке. Для каждого типа строго определены наборы допустимых значений и разрешенных операций.
				</p>
					<h4>2.1.1. Числовые типы</h4>
				<p>	
					Числовые типы - это типы, предназначенные для хранения чисел. Когда вы выполняете математические операции, вы имеете дело с
					числовыми значениями. Существует два вида числовых типов. Те, которые предназначены для хранения чисел без дробной части, называются
					<b>целыми</b> типами, а те, в которых может храниться и дробная часть числа -<b>вещественными</b>, или типами с <b>плавающей точкой</b>.
				</p>
				<p>
					В языке Java понятие беззнаковых чисел отсутствует. Все числовые типы этого языка — знаковые. Например, если значение переменной
					типа byte равно в шестнадцатиричном виде 0x80, то это число -1.
				</p>
					<h5>2.1.1.1. Целые типы</h5>
				<p>		
					Отсутствие в Java беззнаковых чисел вдвое сокращает количество целых типов. В языке имеется 4 целых типа, занимающих 1, 2, 4 и 8 байтов в памяти.
					Для каждого типа — byte, short, int и long - есть свои естественные области применения.
				</p>	
				<p><b>Тип byte</b></p>
				<p>
					Тип byte — это знаковый 8-битовый тип. Его диапазон — от -128 до 127. Он лучше всего подходит для хранения произвольного потока байтов,
					загружаемого из сети или из файла,
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							byte b;<br>
							byte с = 11;							
						</div>
						</div>
					</div>					 
				</div>
				<p>	
					Если речь не идет о манипуляциях с битами, использования типа byte, как правило, следует избегать. Для нормальных целых чисел, используемых в качестве 
					счетчиков и в арифметических выражениях, гораздо лучше подходит тип int.	
				</p>	
				<p><b>Тип short</b></p>	
				<p>	
					Short — это знаковый 16-битовый тип. Его диапазон — от -32768 до 32767. Это, вероятно, наиболее редко используемый в Java тип, поскольку он определен
					как тип, в котором старший байт стоит первым,
				</p>	
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							short s;<br>
							short t= 129; 							
						</div>
						</div>
					</div>					 
				</div>
				<p><b>Тип int</b></p>	
				<p>
					Тип int служит для представления 32-битных целых чисел со знаком. Диапазон допустимых для этого типа значений — от -2147483648 до 2147483647. Чаще
					всего этот тип данных используется для хранения обычных целых чисел со значениями, достигающими двух миллиардов. Этот тип прекрасно подходит для 
					использования при обработке массивов и для счетчиков. В ближайшие годы этот тип будет прекрасно соответствовать машинным словам не только 32-битовых
					процессоров, но и 64-битовых с поддержкой быстрой конвейеризации для выполнения 32-битного кода в режиме совместимости. Всякий раз, когда в одном выражении
					фигурируют переменные типов byte, short, int и целые литералы, тип всего выражения перед завершением вычислений приводится к int.				
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							int i;<br>
							int j = 1000; 							
						</div>
						</div>
					</div>					 
				</div>
				<p><b>Тип int</b></p>
				<p>	
					Тип long предназначен для представления 64-битовых чисел со знаком. Его диапазон допустимых значений достаточно велик даже для таких задач,
					как подсчет числа атомов во вселенной,
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							long m;<br>
							long n = 123; 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					He надо отождествлять разрядность целочисленного типа с занимаемым им количеством памяти. Исполняющий код Java может использовать для ваших
					переменных то количество памяти, которое сочтет нужным, лишь бы только их поведение соответствовало поведению типов, заданных вами.
				</p>
				<p>	
					<b>Таблица 2.1. Таблица разрядностей и допустимых диапазонов для различных типов целых чисел</b>
				</p>
				<div class="table-responsive">
					<table class="table table-condensed table-hover">
						<thead>
						<tr>
							<th>№</th>
							<th>Имя</th>
							<th>Разрядность</th>
							<th>Диапазон</th>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>1</td>
							<td>long</td>
							<td>64</td>
							<td>-9, 223, 372,036, 854, 775, 808 ... 9, 223, 372, 036, 854, 775, 807</td>
						</tr>
						<tr>
							<td>2</td>
							<td>int</td>
							<td>32</td>
							<td>-2, 147, 483, 648 .... 2, 147, 483, 647</td>
						</tr>
						<tr>
							<td>3</td>
							<td>short</td>
							<td>16</td>
							<td>-32,768 .... 32, 767</td>
						</tr>
						<tr>
							<td>4</td>
							<td>byte</td>
							<td>8</td>
							<td>-128 ... 127</td>
						</tr>						
						</tbody>
					</table> 
				</div>
				<p>
					<h5>2.1.1.2. Числа с плавающей точкой</h5>
				</p>
				<p>	
					Числа с плавающей точкой, часто называемые в других языках вещественными числами, используются при вычислениях, в которых требуется 
					использование дробной части. В Java реализован стандартный (IEEE-754) набор типов для чисел с плавающей точкой — float и double
					и операторов для работы с ними.
				</p>
				<p>	
					<b>Таблица 2.2. Характеристики типов чисел с плавающей точкой</b>
				</p>	
				<div class="table-responsive">
					<table class="table table-condensed table-hover">
						<thead>
						<tr>
							<th>№</th>
							<th>Имя</th>
							<th>Разрядность</th>
							<th>Диапазон</th>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>1</td>
							<td>double</td>
							<td>64</td>
							<td>1.7e-308 .... 1.7e+ 308</td>
						</tr>
						<tr>
							<td>2</td>
							<td>float</td>
							<td>32</td>
							<td>3.4e-038 .... 3.4e+ 038</td>
						</tr>												
						</tbody>
					</table> 
				</div>
				<p><b>Тип float</b></p>
				<p>	
					В переменных с обычной, или одинарной точностью, объявляемых с помощью ключевого слова float, для хранения вещественного 
					значения используется 32 бита,
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							float f;<br>
							float f2 = 3.14; 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В случае <b>двойной точности</b>, задаваемой с помощью ключевого слова double, для хранения значений используется 64 бита. Все 
					<b>трансцендентные</b> математические функции, такие как sin, cos, sqrt, возвращают результат типа double,
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							double d;<br>
							double pi = 3.14159265358979323846;							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h4>2.1.2. Символы</h4>
				</p>
				<p>
					Поскольку в Java для представления символов в строках используется кодировка Unicode, разрядность типа char в этом языке — 16 бит.
					В нем можно хранить десятки тысяч символов интернационального набора символов Unicode. Диапазон типа char — 0..65536. Unicode — 
					это объединение десятков кодировок символов, он включает в себя латинский, греческий, арабский алфавиты, кириллицу и многие другие
					наборы символов,
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							char с;<br>
							char с2 = 0xf132;<br>
							char с3 =’а’;<br>
							char с4 = ‘\n’;						
						</div>
						</div>
					</div>					 
				</div>
				<p>				
					Хотя величины типа char и не используются как целые числа, вы можете оперировать с ними так, как если бы они были целыми. Это дает
					вам возможность сложить два символа вместе, или инкрементировать значение символьной переменной. В приведенном ниже фрагменте кода мы,
					располагая базовым символом, прибавляем к нему целое число, чтобы получить символьное представление нужной нам цифры,
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							int  three = 3;<br> 
							char one = ‘1’;<br> 
							char four = (char) (three+ one);					
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В результате выполнения этого кода в переменную four заносится символьное представление нужной нам цифры — '4'. Обратите внимание
					— тип переменной one в приведенном выше выражении повышается до типа int, так что перед занесением результата в переменную four
					приходится использовать оператор явного приведения типа.
				</p>
				<p>
					<h4>2.1.3. Тип boolean</h4>
				</p>
				<p>
					В языке Java имеется простой тип boolean, используемый для хранения логических значений. Переменные этого типа могут принимать всего
					два значения — true (истина) и false (ложь). Значения типа boolean возвращаются в качестве результата всеми операторами сравнения,
					например (а < b) — об этом разговор пойдет в следующей главе. Кроме того, вы узнаете, что boolean — это тип, <b>требуемый</b> всеми условными
					операторами управления — такими, как if, while, do,
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							boolean done = false;					
						</div>
						</div>
					</div>					 
				</div>
				<h2>2.2. Приведение типов</h2>
				<p>
					Иногда возникают ситуации, когда у вас есть величина какого-то определенного типа, а вам нужно ее присвоить переменной другого типа. Для некоторых
					типов это можно проделать и без приведения типа, в таких случаях говорят об автоматическом преобразовании типов. В Java автоматическое преобразование
					возможно только в том случае, когда точности представления чисел переменной-приемника достаточно для хранения исходного значения. Такое преобразование
					происходит, например, при занесении литеральной константы или значения переменной типа byte или short в переменную типа int. Это называется <b>расширением
					(widening)</b> или <b>повышением (promotion)</b>, поскольку тип меньшей разрядности расширяется (повышается) до большего совместимого типа. Размера типа int всегда
					достаточно для хранения чисел из диапазона, допустимого для типа byte, поэтому в подобных ситуациях оператора явного приведения типа не требуется. Обратное
					в большинстве случаев неверно, поэтому для занесения значения типа int в переменную типа byte необходимо использовать оператор приведения типа. Эту процедуру
					иногда называют <b>сужением (narrowing)</b>, поскольку вы явно сообщаете транслятору, что величину необходимо преобразовать, чтобы она уместилась в переменную нужного
					вам типа. Для приведения величины к определенному типу перед ней нужно указать этот тип, заключенный в круглые скобки. В приведенном ниже фрагменте кода
					демонстрируется приведение типа источника (переменной типа int) к типу приемника (переменной типа byte). Если бы при такой операции целое значение выходило
					за границы допустимого для типа byte диапазона, оно было бы уменьшено путем деления по модулю на допустимый для byte диапазон (результат деления по модулю
					на число — это остаток от деления на это число),
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							int а = 100;<br>
							byte b = (byte) а;					
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h4>2.2.1. Автоматическое преобразование типов в выражениях</h4>
				</p>
				<p>
					При вычислениях значения выражения точность, требуемая для хранения промежуточных результатов, зачастую должна быть выше, чем требуется для представления
					окончательного результата,
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							byte а = 40;<br>
							byte b = 50;<br>
							byte с = 100;<br>
							int d = a* b / с;					
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Результат промежуточного выражения (а*b) вполне может выйти за диапазон допустимых для типа byte значений. Именно поэтому Java автоматически повышает
					тип каждой части выражения до типа int, так что для промежуточного результата (а* b) хватает места.
				</p>
				<p>
					Автоматическое преобразование типа иногда может оказаться причиной неожиданных сообщений транслятора об ошибках. Например, показанный ниже код,
					хотя и выглядит вполне корректным, приводит к сообщению об ошибке на фазе трансляции. В нем мы пытаемся записать значение 50*2, которое должно
					прекрасно уместиться в тип byte, в байтовую переменную. Но из-за автоматического преобразования типа результата в int мы получаем сообщение об ошибке
					от транслятора — ведь при занесении int в byte может произойти потеря точности.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							byte b = 50;<br>
							b = b* 2:<br>
							^Incompatible type for =. Explicit cast needed to convert int to byte.<br> 
							(Несовместимый тип для =. Необходимо явное преобразование int в byte)<br>
							Исправленный текст:<br> 
							byte b = 50;<br>
							b = (byte) (b* 2);<br>
							что приводит к занесению в b правильного значения 100.					
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Если в выражении используются переменные типов byte, short и int, то во избежание переполнения тип всего выражения автоматически повышается до int. 
					Если же в выражении тип хотя бы одной переменной — long, то и тип всего выражения тоже повышается до long. Не забывайте, что все целые литералы, в 
					конце которых не стоит символ L (или 1), имеют тип int.
				</p>
				<p>
					Если выражение содержит операнды типа float, то и тип всего выражения автоматически повышается до float. Если же хотя бы один из операндов имеет
					тип double, то тип всего выражения повышается до double. По умолчанию Java рассматривает все литералы с плавающей точкой как имеющие тип double. 
					Приведенная ниже про1рамма показывает, как повышается тип каждой величины в выражении для достижения соответствия со вторым операндом каждого бинарного оператора.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>class Promote { <br>
								public static void main (String args []) { <br>
									byte b= 42; <br>
									char с = 'a’; <br>
									shorts = 1024; <br>
									int i = 50000; <br>
									float f = 5.67f; <br>
									doubled =.1234; <br>
									double result = (f*b) + (i/ c) - (d* s); <br>
									System, out. println ((f* b)+ "+ "+ (i / c)+ " -" + (d* s)); <br>
									System, out. println ("result = "+ result); } <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Подвыражение f*b — это число типа float, умноженное на число типа byte, поэтому его тип автоматически повышается до float. Тип следующего подвыражения
					i / с (int, деленный на char) повышается до int. Аналогично этому тип подвыражения d*s (double, умноженный на short) повышается до double. На следующем
					шаге вычислений мы имеем дело с тремя промежуточными результатами типов float, int и double. Сначала при сложении первых двух тип int повышается до float
					и получается результат типа float. При вычитании из него значения типа double тип результата повышается до double. Окончательный результат всего выражения
					— значение типа double.
				</p>
				<p>
					Теперь, когда мы познакомились со всеми простыми типами, включая целые и вещественные числа, символы и логические переменные, давайте попробуем собрать
					всю информацию вместе. В приведенном ниже примере создаются переменные каждого из простых типов и выводятся значения этих переменных.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class SimpleTypes { <br>
									public static void main(String args []) { <br>
										byte b = 0x55; <br>
										short s = 0x55ff; <br>
										int i = 1000000; <br>
										long l = 0xffffffffL; <br>
										char с = ’a’; <br>
										float f= .25f; <br>
										double d = .00001234; <br>
										boolean bool = true; <br>
										System.out.println("byte b = " + b); <br>
										System.out.println("short s = " +s); <br>
										System.out.println("int i =” + i); <br>
										System.out.println("long 1 = " + l); <br>
										System.out.println("char с =” + с); <br>
										System.out.println("float f = " + f); <br>
										System.out.println("double d = " + d); <br>
										System.out.println("boolean bool =” + bool);<br>
									} <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Запустив эту программу, вы должны получить результат, показанный ниже:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							byte b = 85 <br>
							shorts = 22015 <br>
							int i = 1000000 <br>
							long 1 = 4294967295 <br>
							char с = a <br>
							float f = 0.25 <br>
							double d=1.234e-005 <br>
							boolean bool = true					
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Обратите внимание на то, что целые числа печатаются в десятичном представлении, хотя мы задавали значения некоторых из них в
					шестнадцатиричном формате.
				</p>
				<hr>
        
				<h2 id="sec3">МАССИВЫ</h2>
				<p>
					Массив - это группа переменных одного типа, доступ к которым осуществляется с помощью общего имени. Для объявления типа массива
					используются квадратные скобки. В приведенной ниже строке объявляется переменная month_days, тип которой — «массивцелых чисел
					типа int».
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							int month_days [];				
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Для того чтобы зарезервировать память под массив, используется специальный оператор <b>new</b>. При использовании этого оператора необходимо
					указать требуемый тип элементов и неотрицательное число элементов, которые нужно иметь в массиве. В приведенной ниже строке кода с 
					помощью оператора <b>new</b> массиву month_days выделяется память для хранения двенадцати целых чисел.
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							month_days = new int [12];				
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Итак, теперь month_days — это ссылка на двенадцать целых чисел. Ниже приведен пример, в котором создается массив, элементы которого содержат
					число дней в месяцах года (невисокосного).
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class Array { <br>
									public static void main (String args []) { <br>
										int month_days[]; <br>
										month_days = new int[12]; <br>
										month_days[0] = 31; <br>
										month_days[l] = 28; <br>
										month_days[2] =31; <br>
										month_days[3] = 30; <br>
										month_days[4] =31; <br>
										month_days[5] = 30; <br>
										month_days[6] = 31; <br>
										month_days[7] = 31; <br>
										month_days[8] = 30; <br>
										month_days[9] = 31; <br>
										month_days[10] = 30; <br>
										month_days[ 11 ] = 31; <br>
										System.out.println("Апрель содержит” + month_days[3] +” дней.");<br>
									} <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					При запуске эта <b>программа</b> печатает количество дней в апреле. Нумерация элементов массива в 
					Java начинается с нуля, так что число дней в апреле — это month_days [3].
				</p>
				<p>
					Имеется возможность автоматически инициализировать массивы способом, во многом напоминающим инициализацию 
					переменных простых типов. Инициализатор массива представляет собой список разделенных запятыми выражений,
					заключенный в фигурные скобки. Запятые отделяют друг от друга значения элементов массива. При таком способе 
					создания массив будет содержать ровно столько элементов, сколько требуется для хранения значений, указанных 
					в списке инициализации.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class AutoArray { <br>
									public static void main(String args[]) { <br>
										intmonth_days[] = { 31,28,31,30,31,30, 31, 31,30,31, 30, 31 }; <br>
										System.out.println("Апрель содержит " + month_days[3] + " дней."); } <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Java строго следит за тем, чтобы вы случайно не записали или не попытались получить значения, выйдя за границы массива.
					При выполнении программы Java проверяет, все ли индексы попадают в допустимый диапазон. Если же вы попытаетесь использовать
					в качестве индексов значения, выходящие за границы массива — отрицательные числа либо числа, которые больше или равны количеству
					элементов в массиве, то получите сообщение об ошибке времени выполнения.
				</p>
				<h2>3.1. Многомерные массивы</h2>
				<p>
					На самом деле настоящих многомерных массивов в Java не существует. Зато имеются массивы массивов, которые ведут себя подобно многомерным
					массивам за исключением нескольких незначительных отличий. Приведенный ниже код создает традиционную матрицу из десяти элементов типа
					double, каждый из которых инициализируется нулем. Внутренняя реализация этой матрицы — массив массивов double.
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							double matrix [][] = new double [5][2];							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Следующий фрагмент кода инициализирует такое же количество памяти, но память под вторую размерность отводится вручную. Это сделано
					для того, чтобы наглядно показать, чтоматрица на самом деле представляет собой вложенные массивы.
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							double matrix [][] = new double [5][]; <br>
							matrix [0] = new double[2]; <br>
							matrix[l] =new double[2]; <br>
							matrix[2] = new double[2]; <br>
							matrix[3] = { 0,1}; <br>
							matrix[4] = { 2,3};							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В следующем примере создается матрица размером 4 на 4 с элементами типа double, причем ее диагональные элементы (те, для которых х==у)
					заполняются единицами, а все остальные элементы остаются равными нулю.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class Matrix { <br>
									public static void main(String args[]) { <br>
										double m[][]; m = new double[4][4]; <br>
										m[0][0]=l; <br>
										m[l][l] = l; <br>
										m[2][2] = l; <br>
										m[3][3] = l; <br>
										System.out.println(m[0][0] +" "+ m[0][l] +" "+ m[0][2] +" "+ m[0][3]); <br>
										System.out.println(m[1][0] +" "+ m[l][l] +" "+ m[l][2] +" "+ m[l][3]); <br>
										System.out.println(m[2][0] +" "+ m[2][l] +" "+ m[2][2] +" "+ m[2][3]); <br>
										System.out.println(m[3][0] +" "+ m[3][l] +" "+ m[3][2] +" "+ m[3][3]); <br>
									} <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Запустив эту программу, вы получите следующий результат:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							1000 <br>
							0100 <br>
							0010 <br>
							0001<br>							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Обратите внимание — если вы хотите, чтобы значение элемента было нулевым, вам не нужно его инициализировать, это делается автоматически.
					Для задания начальных значений массивов существует специальная форма инициализатора, пригодная и в многомерном случае. В про1рамме,
					приведенной ниже, создается матрица, каждый элемент которой содержит произведение номера строки на номер столбца. Обратите внимание 
					на тот факт, что внутри инициализатора массива можно использовать не только литералы, но и выражения.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class AutoMatrix { <br>
									public static void main(String args[]) { <br>
										double m[][]={ <br>
										{ 0*0,1*0,2*0,3*0 }, { 0*1,1*1,2*1,3*1 }, { 0*2.1*2,2*2,3*2 }, <br>
										{0*3,1*3.2*3,3*3 } }; <br>
										System.out.println(m[0][0] +" "+ m[0][l] +" "+ m[0][2] +" "+ m[0][3]); <br>
										System.out.println(m[ 1 ][0] +" "+m[l][l] +" "+m[l][2] +" "+m[l][3]); <br>
										System.out.println(m[2][0] +" "+m[2][l] +" "+m[2][2] +" "+ m[2][3]); <br>
										System.out.println(m[3][0] +" "+m[3][l] +" "+ m[3][2] +" "+ m[3][3]); <br>
									} <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Запустив эту программу, вы получите следующий результат:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							0000 0123 <br>
							0246 0369 							
						</div>
						</div>
					</div>					 
				</div>				
				<h2 id="sec4">ОПЕРАТОРЫ</h2>
				<p>
					Операторы в языке <b>Java</b> — это специальные символы, которые сообщают транслятору о том, что вы хотите выполнить операцию с некоторыми 
					операндами. Типы операций указываются с помощью операторов, а операнды - это переменные, выражения или литералы. Некоторые операторы
					требуют одного операнда, их называют <b>унарными</b>. Одни операторы ставятся перед операндами и называются <b>префиксными</b>, другие — после, их
					называют <b>постфиксными</b> операторами. Большинство же операторов ставят между двумя операндами, такие операторы называются <b>инфиксными</b> бинарными
					операторами. Существует тернарный оператор, работающий с тремя операндами. В Java имеется 44 встроенных оператора. Их можно разбить
					на 4 класса — <b>арифметические, битовые, операторы сравнения</b> и <b>логические</b>.
				</p>
				<h5>4.1. Арифметические операторы</h5>
				<p>
					Арифметические операторы используются для вычислений так же как в алгебре (см. таблицу со сводкой арифметических операторов ниже). Допустимые
					операнды должны иметь числовые типы. Например, использовать эти операторы для работы с логическими типами нельзя, а для работы с типом
					char можно, поскольку в Java тип char — это подмножествотипа int.
				</p>
				<b>Таблица 4.1. Таблица арифметических операторов</b>
				<div class="table-responsive">
					<table class="table table-condensed table-hover">
						<thead>
						<tr>
							<th>№</th>
							<th>Оператор</th>
							<th>Результат</th>
							<th>Оператор</th>
							<th>Результат</th>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>1</td>
							<td>+</td>
							<td>Сложение</td>
							<td>+ =</td>
							<td>Сложение с присваиванием</td>
						</tr>
						<tr>
							<td>2</td>
							<td>-</td>
							<td>Вычитание (также унарный минус)</td>
							<td>- =</td>
							<td>Вычитание с присваиванием</td>
						</tr>
						<tr>
							<td>3</td>
							<td>*</td>
							<td>Умножение</td>
							<td>* =</td>
							<td>Умножение с присваиванием</td>
						</tr>
						<tr>
							<td>4</td>
							<td>/</td>
							<td>Деление</td>
							<td>/ =</td>
							<td>Деление с присваиванием</td>
						</tr>
						<tr>
							<td>5</td>
							<td>%</td>
							<td>Деление по модулю</td>
							<td>% =</td>
							<td>Деление по модулю с присваиванием</td>
						</tr>
						<tr>
							<td>6</td>
							<td>++</td>
							<td>Инкремент</td>
							<td>--</td>
							<td>Декремент</td>
						</tr>
						</tbody>
					</table> 
				</div>
				<p>
					Ниже в качестве примера, приведена простая программа, демонстрирующая использование операторов. Обратите внимание на то, что операторы работают
					как с целыми литералами, так и с переменными.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class BasicMath { <br>
									public static void int a = 1 + 1; <br>
										int b = a* 3; <br>
										main(String args[]) { <br>
											int с = b / 4; <br>
											int d = b - a; <br>
											int e = -d; <br>
											System.out.print("a = " + a); <br>
											System.out.print("b = " + b); <br>
											System.out.print("c = " + c); <br>
											System.out.print("d = " + d); <br>
											System.out.println("e =” + e); <br>
										} <br>
									}<br>

							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Исполнив эту программу, вы должны получить приведенный ниже результат:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							a = 2 <br>
							b = 6 <br>
							c = 1 <br>
							d = 4 <br>
							e = -4<br>							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h4>4.1.1. Оператор деления по модулю</h4>
				</p>
				<p>
					Оператор деления по модулю - оператор mod, обозначается символом %. Этот оператор возвращает остаток от деления первого операнда на
					второй. Функция mod в Java работает не только с целыми, но и с вещественными типами. Приведенная ниже программа иллюстрирует работу
					этого оператора.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class Modulus { <br>
									public static void main (String args []) { <br>
										int x = 42; <br>
										double у = 42.3; <br>
										System.out.print("x mod 10 = " + x % 10); <br>
										System.out.println("y mod 10 = " + у % 10); <br>
									} <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Выполнив эту программу, вы получите следующий результат:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							х mod 10 = 2 у mod 10 = 2.3						
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h4>4.1.2. Арифметические операторы присваивания</h4>
				</p>
				<p>
					Для каждого из арифметических операторов есть форма, в которой одновременно с заданной операцией выполняется присваивание. Если требуется
					написать <b>а += 4</b>, то с таким же успехом можно использовать <b>а = а + 4</b>.
				</p>				
				<div class="row">
					<div class="col-md-12">
						<div class="panel panel-default">
						<div class="panel-heading"><h4>Такой способ пригоден для всех бинарных операторов, которые используются в выражениях вида:</h4></div>
						<div class="panel-body">переменная = переменная оператор выражение;</div>
						</div>
					</div>					 
				</div>
				<div class="row">
					<div class="col-md-12">
						<div class="panel panel-default">
						<div class="panel-heading"><h4>Любой такой оператор можно записать в короткой форме:</h4></div>
						<div class="panel-body">переменная оператор = выражение;</div>
						</div>
					</div>					 
				</div>				
					<h4>4.1.3. Инкремент и декремент</h4>
				</p>
				<p>
					В Java существует два оператора, называемых операторами инкремента и декремента (++ и --) и являющихся сокращенным вариантом записи
					для сложения или вычитания из операнда единицы. Эти операторы уникальны в том плане, что могут использоваться как в префиксной,
					так и в постфиксной форме. При использовании префиксной формы операнд модифицируется перед выполнением операции. В постфиксной
					форме сначала используется содержимое операнда, а лишь после этого операнд инкрементируется или декрементируется. Следующий пример
					иллюстрирует использование операторов инкремента и декремента.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class IncDec { <br>
									public static void main(String args[]){ <br>
										int a = 1; <br>
										int b = 2; <br>
										int с = ++b; <br>
										int d = a++; <br>
										c++; <br>
										System.out.print("a = " + a); <br>
										System.out.print("b = " + b); <br>
										System.out.print("c = " + c); <br>
										System.out.println("d = " + d); <br>
									} <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Результат выполнения данной программы будет таким:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							a=2 b=3 c=4 d=1						
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>4.2. Целочисленные битовые операторы</h2>
				</p>
				<p>
					Для целых числовых типов данных — long, int, short, char и byte - определен дополнительный набор операторов, с помощью которых можно
					проверять и модифицировать состояние отдельных битов соответствующих значений. В таблице 4.2 приведена сводка таких операторов. 
					Операторы битовой арифметики работают с каждым битом как с самостоятельной величиной.
				</p>
				<b>Таблица 4.2. Операторы битовой арифметики</b>
				<div class="table-responsive">
					<table class="table table-condensed table-hover">
						<thead>
						<tr>
							<th>№</th>
							<th>Оператор</th>
							<th>Результат</th>
							<th>№</th>
							<th>Оператор</th>
							<th>Результат</th>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>1</td>
							<td>&</td>
							<td>побитовое И (AND)</td>
							<td>8</td>
							<td>&=</td>
							<td>Побитовое И (AND) с присваиванием</td>
						</tr>
						<tr>
							<td>2</td>
							<td>|</td>
							<td>побитовое ИЛИ(OR</td>
							<td>9</td>
							<td>|=</td>
							<td>побитовое ИЛИ (OR) с присваиванием</td>
						</tr>
						<tr>
							<td>3</td>
							<td>^</td>
							<td>побитовое исключающее ИЛИ(XOR)</td>
							<td>10</td>
							<td>^=</td>
							<td>побитовое исключающее ИЛИ (XOR) с присваиванием</td>
						</tr>
						<tr>
							<td>4</td>
							<td>>> </td>
							<td>сдвиг вправо</td>
							<td>11</td>
							<td>>>=</td>
							<td>сдвиг вправо с присваиванием</td>
						</tr>
						<tr>
							<td>5</td>
							<td>>>> </td>
							<td>сдвиг вправо с заполнением нулями</td>
							<td>12</td>
							<td>>>>=</td>
							<td>сдвиг вправо с заполнением нулями с присваиванием</td>
						</tr>
						<tr>
							<td>6</td>
							<td><< </td>
							<td>сдвиг влево</td>
							<td>13</td>
							<td><<=</td>
							<td>сдвиг влево с присваиванием</td>
						</tr>
						<tr>
							<td>7</td>
							<td>~</td>
							<td>побитовое унарное отрицание (NOT)</td>
							<td></td>
							<td></td>
							<td></td>
						</tr>
						</tbody>
					</table> 
				</div>
				<p>
					В таблице 4.3 показано, как каждый из операторов битовой арифметики воздействует на возможные комбинации битов своих операндов.
				</p>
				<b>Таблица 4.3</b>
				<div class="table-responsive">
					<table class="table table-condensed table-hover">
						<thead>
						<tr>
							<th>A</th>
							<th>B</th>
							<th>OR</th>
							<th>AND</th>
							<th>XOR</th>
							<th>NOT A</th>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>0</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>1</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>1</td>
							<td>0</td>
							<td>0</td>
						</tr>
						</tbody>
					</table> 
				</div>
				<p>
					<b>Сдвиг влево</b>
				</p>
				<p>
					Оператор << выполняет сдвиг влево всех битов своего левого операнда на число позиций, заданное правым операндом. При этом часть 
					битов в левых разрядах выходит за границы и теряется, а соответствующие правые позиции заполняются нулями.
				</p>
				<p>
					<b>Сдвиг вправо</b>
				</p>
				<p>
					Оператор >> означает в языке Java сдвиг вправо. Он перемещает все биты своего левого операнда вправо на число позиций,
					заданное правым операндом. Когда биты левого операнда выдвигаются за самую правую позицию слова, они теряются. При сдвиге
					вправо освобождающиеся старшие (левые) разряды сдвигаемого числа заполняются предыдущим содержимым знакового разряда. Сделано 
					это для того, чтобы при сдвиге вправо числа сохраняли свой знак.
				</p>
				<p>
					<b>Беззнаковый сдвиг вправо</b>
				</p>
				<p>
					Часто требуется, чтобы при сдвиге вправо расширение знакового разряда не происходило, а освобождающиеся левые разряды заполнялись
					бы нулями. С этой целью используется оператор беззнакового сдвига вправо >>>.
				</p>
				<p>
					<h5>4.3. Операторы отношений</h5>
				</p>
				<p>
					Для того чтобы можно было сравнивать два значения, в Java имеется набор операторов, описывающих отношение и равенство.
					Список таких операторов приведен в таблице 4.4.
				</p>
				<b>Таблица 4.4</b>
				<div class="table-responsive">
					<table class="table table-condensed table-hover">
						<thead>
						<tr>
							<th>№</th>
							<th>Оператор</th>
							<th>Результат</th>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>1</td>
							<td>==</td>
							<td>равно</td>
						</tr>
						<tr>
							<td>2</td>
							<td>!=</td>
							<td>не равно</td>
						</tr>
						<tr>
							<td>3</td>
							<td>></td>
							<td>больше</td>
						</tr>
						<tr>
							<td>4</td>
							<td><</td>
							<td>меньше</td>
						</tr>
						<tr>
							<td>5</td>
							<td>>=</td>
							<td>больше или равно</td>
						</tr>
						<tr>
							<td>5</td>
							<td><=</td>
							<td>меньше или равно</td>
						</tr>
						</tbody>
					</table> 
				</div>
				<p>
					Значения любых типов, включая целые и вещественные числа, символы, логические значения и ссылки, можно сравнивать, используя оператор 
					проверки на равенство == инеравенство !=. Обратите внимание — в языке Java проверка на равенство обозначается последовательностью (==). 
					Один знак (=) — это оператор присваивания.
				</p>
				<p>
					Операторы отношения могут применяться только к операндам числовых типов. С их помощью можно работать с целыми, вещественными и 
					символьными типами. Каждый из операторов отношения возвращает результат типа boolean, т.е. либо <b>true</b>, либо <b>false</b>.
				</p>
				<p>
					<h2>4.4. Булевы логические операторы</h2>
				</p>
				<p>
					Булевы логические операторы, перечень которых приведен в таблице 4.5, оперируют только с операндами типа boolean. Все бинарные
					логические операторы воспринимают в качестве операндов два значения типа boolean и возвращают результат того же типа.
				</p>
				<b>Таблица 4.5. Таблица булевых логических операторов</b>
				<div class="table-responsive">
					<table class="table table-condensed table-hover">
						<thead>
						<tr>
							<th>№</th>
							<th>Оператор</th>
							<th>Результат</th>
							<th>№</th>
							<th>Оператор</th>
							<th>Результат</th>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>1</td>
							<td>&</td>
							<td>логическое И (AND)</td>
							<td>7</td>
							<td>&=</td>
							<td>И (AND) с присваиванием</td>
						</tr>
						<tr>
							<td>2</td>
							<td>|</td>
							<td>логическое ИЛИ(OR)</td>
							<td>8</td>
							<td>=</td>
							<td>ИЛИ (OR) с присваиванием</td>
						</tr>
						<tr>
							<td>3</td>
							<td>^</td>
							<td>логическое исключающее ИЛИ(XOR)</td>
							<td>9</td>
							<td>^=</td>
							<td>исключающее ИЛИ (XOR) с присваиванием</td>
						</tr>
						<tr>
							<td>4</td>
							<td>||</td>
							<td>оператор OR быстрой оценки выражений (shortcircuit OR)</td>
							<td>10</td>
							<td>==</td>
							<td>равно</td>
						</tr>
						<tr>
							<td>5</td>
							<td>&&</td>
							<td>оператор AND быстрой оценки выражений (shortcircuit AND)</td>
							<td>11</td>
							<td>!=</td>
							<td>не равно</td>
						</tr>
						<tr>
							<td>6</td>
							<td>!</td>
							<td>логическое унарное отрицание (NOT)</td>
							<td>12</td>
							<td>?:</td>
							<td>тернарный оператор if-then-else</td>
						</tr>
						</tbody>
					</table> 
				</div>
				<p>
					Логические булевы операторы AND (И), OR (ИЛИ) и XOR (исключающее ИЛИ) выполняют над логическими величинами те же операции, что 
					и их аналоги из семейства битовой логики. Унарный оператор NOT (НЕ) инвертирует логическое значение. В таблице 4.6 показаны
					результаты воздействия логических операторов на различные комбинации значений операндов.
				</p>
				<b>Таблица 4.6</b>
				<div class="table-responsive">
					<table class="table table-condensed table-hover">
						<thead>
						<tr>
							<th>A</th>
							<th>B</th>
							<th>OR</th>
							<th>AND</th>
							<th>XOR</th>
							<th>NOT A</th>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>false</td>
							<td>false</td>
							<td>false</td>
							<td>false</td>
							<td>false</td>
							<td>true</td>
						</tr>
						<tr>
							<td>true</td>
							<td>false</td>
							<td>true</td>
							<td>false</td>
							<td>true</td>
							<td>false</td>
						</tr>
						<tr>
							<td>false</td>
							<td>true</td>
							<td>true</td>
							<td>false</td>
							<td>true</td>
							<td>true</td>
						</tr>
						<tr>
							<td>true</td>
							<td>true</td>
							<td>true</td>
							<td>true</td>
							<td>false</td>
							<td>false</td>
						</tr>
						</tbody>
					</table> 
				</div>
				<p>
					Существуют два дополнения к набору логических операторов. Это альтернативные версии операторов AND и OR, служащие для быстрой
					оценки логических выражений. Если первый операнд оператора OR имеет значение true, то независимо от значения второго 
					операнда результатом операции будет величина true. Аналогично в случае оператора AND, если первый операнд — false, то 
					значение второго операнда на результат не влияет — он всегда будет равен false. Если вы используете операторы && и ||
					вместо обычных форм & и |, то Java не производит оценку правого операнда логического выражения, если ответ ясен из значения
					левого операнда. Общепринятой практикой является использование операторов && и || практически во всех случаях оценки 
					булевых логических выражений. Версии этих операторов & и | применяются только в битовой арифметике.
				</p>
				<p>
					<h2>4.5. Тернарный оператор if-then-else</h2>
				</p>
				<div class="row">
					<div class="col-md-12">
						<div class="panel panel-default">
						<div class="panel-heading"><h4>Общая форма оператора if-then-else такова:</h4></div>
						<div class="panel-body">Выражение1 ? Выражение2 : выражениеЗ</div>
						</div>
					</div>					 
				</div>
				<p>
					В качестве первого операнда — «выражение 1» — может быть использовано любое выражение, результатом которого является
					значение типа boolean. Если результат равен true, то выполняется оператор, заданный вторым операндом, то есть «выражение2».
					Если же первый операнд равен false, то выполняется третий операнд — «выражениеЗ». Второй и третий операнды, то есть «выражение2»
					и «выражениеЗ», должны возвращать значения одного типа и не должны иметь тип void. В приведенной ниже программе этот
					оператор используется для проверки делителя перед выполнением операции деления. В случае нулевого делителя возвращается значение 0.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class Ternary { <br>
									public static void main(String args[]) { <br>
										int a = 42; <br>
										int b = 2; <br>
										int с = 99; <br>
										int d = 0; <br>
										int e = (b == 0) ? 0 : (a / b); <br>
										int f = (d == 0) ? 0 : (c / d); <br>
										System.out.print("a = " + a); <br>
										System.out.print("b = " + b); <br>
										System.out.print("c = " + c); <br>
										System.out.print("d = " + d); <br>
										System.out.print("a / b = " + e); <br>
										System.out.println("c / d = " + f); <br>
									} <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					При выполнении этой программы исключительной ситуации деления на нуль не возникает, и выводятся следующие результаты:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							a = 42 <br>
							b = 2 <br>
							c = 99 <br>
							d = 0 <br>
							a/b = 21 <br>
							c/d = 0							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>4.6. Приоритеты операторов</h2>
				</p>
				<p>
					В Java действует определенный порядок, или приоритет, операций. В элементарной алгебре умножение и деление имеют более высокий приоритет,
					чем сложение и вычитание. В программировании также приходится следить за приоритетами операций. В таблице 4.7. указаны в порядке
					убывания приоритеты всех операций языка Java.
				</p>
				<b>Таблица 4.7. Таблица приоритетов всех операций</b>
				<div class="table-responsive">
					<table class="table table-condensed table-hover">
						<thead>
						<tr>
							<th>№</th>
							<th>Высший</th>							
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>1</td>
							<td>()</td>
							<td>[]</td>
							<td>•</td>
							<td></td>
						</tr>
						<tr>
							<td>2</td>
							<td>~</td>
							<td>!</td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>3</td>
							<td>*</td>
							<td>/</td>
							<td>%</td>
							<td></td>
						</tr>
						<tr>
							<td>4</td>
							<td>+</td>
							<td>-</td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>5</td>
							<td>>></td>
							<td>>>></td>
							<td><<</td>
							<td></td>
						</tr>
						<tr>
							<td>6</td>
							<td>></td>
							<td>>=</td>
							<td><</td>
							<td><=</td>
						</tr>
						<tr>
							<td>7</td>
							<td>==</td>
							<td>!=</td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>8</td>
							<td>&</td>
							<td></td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>9</td>
							<td>^</td>
							<td></td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>10</td>
							<td>|</td>
							<td></td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>11</td>
							<td>&&</td>
							<td></td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>12</td>
							<td>||</td>
							<td></td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>13</td>
							<td>?:</td>
							<td></td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td>14</td>
							<td>=</td>
							<td>op=</td>
							<td></td>
							<td></td>
						</tr>
						<tr>
							<td></td>
							<td>Низший</td>							
						</tr>
						</tbody>
					</table> 
				</div>
				<p>
					В первой строке таблицы приведены три необычных оператора, о которых мы пока не говорили. Круглые скобки () используются для явной
					установки приоритета. Квадратные скобки [] используются для индексирования переменной-массива. Оператор . (точка) используется для
					выделения элементов из ссылки на объект.
				</p>				
				<hr>
				<p>
					<h2 id="sec5">УПРАВЛЕНИЕ ВЫПОЛНЕНИЕМ ПРОГРАММЫ</h2>
				</p>
				<p>
					Управление выполнением (flow control) позволяет изменять последовательность выполнения фрагментов программы, выбирая в зависимости
					от состояния данных ту или иную ветвь кода. Ветвление, циклы и вызовы подпрограмм - это разновидности управления выполнением программы.
					Все наши программы до сих пор были полностью линейны - операторы выполнялись строго по порядку, один за другим. В более сложных программах
					часто требуется, чтобы в зависимости от условий выполнялись одни операторы, а другие при этом пропускались. Для управления 
					выполнением программного кода в Java имеется несколько возможностей, основанных на использовании условных операторов.
				</p>
				<p>
					<h5>5.1. Условный оператор if-else</h5>
				</p>
				<p>
					Конструкция <b>if-else</b> позволяет в зависимости от некоторого логического значения выполнять различные части программного кода.
				</p>
				<div class="row">
					<div class="col-md-12">
						<div class="panel panel-default">
						<div class="panel-heading"><h4>В обобщенной форме этот оператор записывается следующим образом:</h4></div>
						<div class="panel-body">if (логическое выражение) оператор 1; [else оператор2;]</div>
						</div>
					</div>					 
				</div>
				<p>
					Раздел <b>else</b> необязателен. На месте любого из <b>операторов</b> может стоять <b>составной оператор</b>, заключенный в фигурные скобки. <b>Логическое</b> выражение
					это любое <b>выражение</b>, возвращающее значение типа boolean. Это может быть и простая переменная типа boolean.
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							int bytesAvailable; <br>
							//... <br>
							if (bytesAvailable > 0) { <br>
							ProcessData();          //Обработка данных <br>
							bytesAvailable  -=  n; <br>
							} <br>
							else <br>
							waitForMoreData();       //Ждать данные						
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В качестве <b>логического выражения</b> можно использовать выражение с операторами отношения. Это позволяет выбирать ту или иную ветвь кода в зависимости от результатов сравнения.
					А вот полная программа, в которой для определения, к какому времени года относится тот или иной месяц, используются операторы if-else.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class IfElse { <br>
									public static void main(String args[]) { <br>
										int month = 4; <br>
										String season; <br>
										if (month == 12 || month == 1 || month == 2) <br>
										{ season = "Winter"; } <br>
										else if (month ==3 || month == 4 || month == 5) <br>
										{ season = "Spring"; } <br>
										else if (month == 6 || month == 7 || month == 8) <br>
										{ season = "Summer"; } <br>
										else if (month == 9 || month == 10 || month == 11) <br>
										{ season = "Autumn"; } <br>
										else <br>
										{ season = "Bogus Month"; } <br>
										System.out.println( "April is in the " + season + "."); <br>
									} <br>
								} <br>
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					После выполнения программы вы должны получить следующий результат: 
				</p>
					<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							April is in the Spring.							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>5.2. Опреатор break</h2>
				</p>
				<p>
					Оператор <b>break</b> сообщает исполняющей среде, что следует прекратить выполнение именованного блока и передать управление оператору, следующему за данным блоком. Для именования блоков в
					языке Java используются метки. Оператор <b>break</b> при работе с циклами и в операторах <b>switch</b> может использоваться без метки. В таком случае подразумевается выход из текущего блока. Для 
					именования блока перед ним помещается метка, состоящая из идентификатора и следующего за ним двоеточия. После объявления метки на нее можно ссылаться в операторе <b>break</b>. При этом управление 
					передается оператору, расположенному за поименованным блоком.
				</p>
				<p>	
					Например, в следующей программе имеется три вложенных блока, и у каждого своя уникальная метка. Оператор break, стоящий во внутреннем блоке, вызывает переход на оператор, следующий за 
					блоком Ь. При этом пропускаются два оператора println.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class Break { <br>
									public static void main(String args[]) { <br>
										boolean t = true; <br>
										a: { <br>
											b:       { <br>
												c:                   { <br>
												System.out.println("ITepefl break"); <br>
												if(t) break b; <br>
												System.out.println("He будет выполнено ");     } <br>
											System.out.println("He будет выполнено ");     } <br>
											System.out.println("noane b"); <br>
										} <br>
									}<br>
								}<br>
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В результате исполнения программы вы получите следующий результат:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							До break <br>
							После b							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>5.3. Оператор switch</h2>
				</p>
				<p>
					Оператор <b>switch</b> обеспечивает ясный способ переключения между различными частями программного кода в зависимости от значения одной переменной или выражения. 
				</p>
				<div class="row">
					<div class="col-md-12">
						<div class="panel panel-default">
						<div class="panel-heading"><h4>Общая форма этого оператора такова:</h4></div>
						<div class="panel-body">switch ( выражение ) <br>
												{ <br>
													case значение1: break; <br>
													case значение2: break; <br>
													case значениеN: break; <br>
													default: <br>
												}
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Результатом вычисления <b>выражения</b> может быть значение любого простого типа, при этом каждое из значений, указанных в операторах <b>case</b>, должно быть совместимо по
					типу с выражением в операторе <b>switch</b>. Все эти значения должны быть уникальными литералами. Если же вы укажете в двух операторах <b>case</b> одинаковые значения,
					транслятор выдаст сообщение об ошибке.
				</p>
				<p>
					Оператор <b>switch</b> работает следующим образом. Вычисленное значение выражения сравнивается со всеми значениями, указанными в операторах <b>case</b>. Если при этом находится оператор
					<b>case</b> со значением, которое совпадает со значением выражения, управление передается стоящему за ним (после двоеточия) коду. Если же значению выражения не соответствует ни
					один из операторов <b>case</b>, управление передается коду, расположенному после ключевого слова <b>default</b>. Отметим, что оператор <b>default</b> необязателен. В случае, когда ни один из
					операторов <b>case</b> не соответствует значению выражения и в <b>switch</b> отсутствует оператор <b>default</b>, выполнение программы продолжается с оператора, следующего за оператором <b>switch</b>.
				</p>
				<p>
					Внутри оператора <b>switch</b> (а также внутри циклических конструкций) <b>break</b> без метки приводит к передаче управления на код, стоящий после оператора <b>switch</b>. Если <b>break</b> отсутствует, после текущего
					раздела <b>case</b> будет выполняться следующий. Иногда бывает удобно иметь в операторе <b>switch</b> несколько смежных разделов <b>case</b>, не разделенных оператором <b>break</b>.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class SwitchSeason { <br>
								public static void main(String args[]) { <br>
								int month = 4; String season; <br>
								switch (month) <br>
								{ <br>
								case 12: <br>
								case 1: <br>
								case 2: <br>
								season = "зима"; <br>
								break; <br>
								case 3: <br>
								case 4: <br>
								case 5: <br>
								season = "весна"; <br>
								break; <br>
								case 6: <br>
								case 7: <br>
								case 8: <br>
								season = "лето"; <br>
								break; <br>
								case 9: <br>
								case 10: <br>
								case 11: <br>
								season = "осень"; <br>
								break; <br>
								default: <br>
								season = "Нет такого месяца"; <br>
								} <br>
								System.out.println("Апрель - это "+ season + "."); <br>
								} <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Ниже приведен еще более полезный пример, где оператор <b>switch</b> используется для передачи управления в соответствии с различными кодами символов во входной строке. Программа подсчитывает
					число строк, слов и символов в текстовой строке,
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class WordCount { <br>
									static String text = "Сейчас мы изучаем\n" + <br>
									"основы программирования\n" + <br>
									"на языке Java\n"; <br>
									static int len = text.length(); <br>
									public static void main(String args[]) { <br>
										boolean inWord = false; <br>
										int numChars = 0; <br>
										int numWords = 0; <br>
										int numLines = 0; <br>
										for (int i=0; i < len; i++) { <br>
											char с = text.charAt(i); <br>
											numChars++; <br>
											switch (c) { <br>
												case ‘\n’: numLines++;        // Увеличиваем счетчик строк <br>
												case '\t':                                   // Подсчитываем количество символов <br>
												case ‘’ : if (inWord) { <br>
													numWords++; <br>
													inWord = false; <br>
												} <br>
												break; <br>
												default: inWord = true; <br>
											} <br>
										} <br>
										System.out.println("\t" + numLines +"\t" + numWords + "\t" + numChars); <br>
									} <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>5.4. Оператор return</h2>
				</p>
				<p>
					В Java для реализации процедурного интерфейса к объектам классов используется разновидность подпрограмм, называемых методами. Подпрограмма main, которую мы использовали до сих пор — это статический
					метод соответствующего класса-примера. В любом месте программного кода метода можно поставить оператор <b>return</b>, который приведет к немедленному завершению работы и передаче управления коду,
					вызвавшему этот метод. Ниже приведен пример, иллюстрирующий использование оператора <b>return</b> для немедленного возврата управления, в данном случае — исполняющей среде Java.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class ReturnDemo { <br>
								public static void main(String args[]) { <br>
								boolean t = true; <br>
								System.out.println("До return"); <br>
								if (t) return; <br>
								System.out.println("Этo не будет выполнено "); <br>
								} <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					ЗАМЕЧАНИЕ: Зачем в этом примере использован оператор if (t)? Дело в том, что не будь этого оператора, транслятор Java догадался бы, что последний оператор println никогда не будет выполнен. Такие 
					случаи в Java считаются ошибками, поэтому без оператора if оттранслировать этот пример нам бы не удалось.
				</p>
				<hr>
				<p>
					<h2 id="sec6">ЦИКЛЫ</h2>
				</p>	
				<p>
					Циклами называются конструкции, в которых один и тот же блок программного кода многократно выполняется до тех пор, пока не будет выполнено условие окончания цикла. Любой цикл можно разделить на 4
					части: <b>инициализацию, тело, итерацию и условие завершения. Инициализация</b> — это код, определяющий начальные условия цикла. <b>Тело</b> -это оператор, выполнение которого необходимо повторить несколько раз.
					<b>Итерация</b> - код, который требуется выполнить сразу после очередного выполнения тела. Код итерации часто используется для увеличения (уменьшения) значений счетчиков и индексов. <b>Завершение</b> -это логическое
					выражение, которое вычисляется на каждом проходе цикла. В зависимости от его значения цикл или завершается или продолжает выполняться. В Java есть три циклические конструкции: <b>while, do-while</b> и  <b>for</b>.
				</p>
				<p>
					<h5>6.1. Цикл while</h5>
				</p>
				<p>
					Цикл <b>while</b> - это основная циклическая конструкция в Java. Этот цикл многократно выполняется до тех пор, пока значение логического выражения равно true. 
				</p>
				<div class="row">
					<div class="col-md-12">
						<div class="panel panel-default">
						<div class="panel-heading"><h4>Ниже приведена общая форма оператора while:</h4></div>
						<div class="panel-body">[ инициализация; ] <br>
												while ( завершение) { <br>
												тело; <br>
												[итерация;] <br>
												}
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Инициализация и итерация необязательны. Пока значение логического выражения равно true, продолжается выполнение тела цикла. Ниже приведен пример цикла <b>while</b> для печати пяти строк «while».
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class WhileDemo { <br>
								public static void main(String args[]) { <br>
								int n = 5; <br>
								while (n > 0) { <br>
								System.out.println("while " + n); <br>
								n--; <br>
								} <br>
								} <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В результате исполнения программы вы получите следующий результат:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							while 5 <br>
							while 4 <br>
							while 3 <br>
							while 2 <br>
							while 1						
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>6.2. Цикл do-while</h2>
				</p>
				<p>
					Иногда возникает потребность выполнить тело цикла по крайней мере один раз, даже в том случае, когда логическое выражение с самого начала принимает значение false. Для таких случаев в Java 
					используется циклическая конструкция do-while.
				</p>
				<div class="row">
					<div class="col-md-12">
						<div class="panel panel-default">
						<div class="panel-heading"><h4>Ее общая форма записи такова:</h4></div>
						<div class="panel-body">[ инициализация; ] <br>
												do {тело; [итерация;] } while ( завершение);
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В следующем примере тело цикла выполняется до первой проверки условия завершения. Это позволяет совместить код итерации с условием завершения:
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class Do While { <br>
								public static void main(String args[]) { <br>
								int n = 5; <br>
								do { <br>
								System.out.println("do-while " + n); <br>
								}  while (--n>0); <br>
								} <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>6.3. Цикл for</h2>
				</p>
				<p>
					Опреатор <b>for</b> предназначен для компактной записи циклов. В этом операторе предусмотрены места для всех четырех частей цикла.
				</p>
				<div class="row">
					<div class="col-md-12">
						<div class="panel panel-default">
						<div class="panel-heading"><h4>Ниже приведена общая форма оператора записи for:</h4></div>
						<div class="panel-body">for (инициализация; завершение; итерация ) тело;</div>
						</div>
					</div>					 
				</div>
				<p>
					Любой цикл, записанный с помощью оператора for, можно записать в виде цикла while и наоборот. Если начальные условия таковы, что 
					при входе в цикл условие завершения не выполнено, то операторы тела и итерации не выполняются ни одного раза. В канонической форме цикла 
					for происходит увеличение целого значения счетчика с минимального значения до определенного предела.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class ForDemo { <br>
								public static void main(String args[]) { <br>
								for (int i = 1; i <= 10; i++) <br>
								System.out.println("i = " + i); <br>
								} <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Следующий пример — вариант программы, ведущей обратный отсчет.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
								class ForTick {  <br>
								public static void main(String args[]) {  <br>
								for (int n = 10; n > 0; n—)  <br>
								System.out.println("n= " + n);  <br>
								}  <br>
								}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Обратите внимание — переменные можно объявлять внутри раздела инициализации оператора <b>for</b>. Переменная, объявленная внутри оператора <b>for</b>,
					действует в пределах этого оператора.
				</p>
				<p>					
					<h4>6.3.1. Оператор запятая</h4>
				</p>
				<p>
					Иногда возникают ситуации, когда разделы инициализации или итерации цикла <b>for</b> требуют нескольких операторов. Поскольку составной оператор в фигурных
					скобках в заголовок цикла <b>for</b> вставлять нельзя, Java предоставляет альтернативный путь. Применение запятой (,) для разделения нескольких операторов
					допускается только внутри круглых скобок оператора <b>for</b>. Ниже приведен пример цикла <b>for</b>, в котором в разделах инициализации и итерации стоит несколько 
					операторов.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class Comma { <br>
							public static void main(String args[]) { <br>
							int a, b; <br>
							for (a = 1, b = 4; a < b; a++, b--) { <br>
							System.out.println("a = " + a); <br>
							System.out.println("b = " + b); <br>
							} <br>
							} <br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>					
					Вывод этой программы показывает, что цикл выполняется всего два раза,
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							а= 1  <br>
							b = 4  <br>
							а = 2  <br>
							b = 3							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>6.4. Оператор continue</h2>
				</p>
				<p>
					В некоторых ситуациях возникает потребность досрочно перейти к выполнению следующей итерации, проигнорировав часть операторов тела цикла, еще не выполненных в текущей
					итерации. В этом случае необходимо сделать переход из текущей точки в конец цикла, т.е. в точку после последнего оператора тела цикла. Для этой цели в Java предусмотрен
					оператор <b>continue</b>. В случае циклов <b>while</b> и <b>do-while</b> оператор <b>continue</b> приводит к пропуску операторов тела цикла, не выполненных на данной итерации, и к передаче управления
					на код, проверяющий условие завершения цикла. Оператор <b>continue</b>, стоящий в цикле <b>for</b>, приводит к тому, что управление немедленно передается третьей части заголовка цикла,
					т.е. коду, который, выполняется на каждой итерации после операторов тела цикла. Ниже приведен пример, в котором оператор <b>continue</b> используется для того, чтобы в каждой 
					строке печатались два числа,
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class ContinueDemo { <br>
							public static void main(String args[]) { <br>
							for (int i=0; i < 10; i++) { <br>
							System.out.print(i + " "); <br>
							if (i % 2 == 0) continue; <br>
							System.out.println(""); <br>
							} <br>
							} <br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Если индекс четный, цикл продолжается без вывода символа новой строки. Результат выполнения этой программы таков:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							0 1 <br>
							2 3 <br>
							5 7 <br>
							8 9							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Как и в случае оператора <b>break</b>, в операторе <b>continue</b> можно задавать метку, указывающую, в каком из вложенных циклов вы хотите досрочно прекратить выполнение текущей итерации.
					Для иллюстрации служит программа, использующая оператор <b>continue</b> с меткой для вывода треугольной таблицы умножения для чисел от 0 до 9:
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class ContinueLabel { <br>
							public static void main(String args[]) { <br>
							outer: for (int i=0; i < 10; i++) { <br>
							for (int j = 0; j < 10; j++) { <br>
							if(j>i){ <br>
							System.out.println(""); <br>
							continue outer; <br>
							} <br>
							System.out.print(" " + (i * j)); <br>
							} <br>
							} <br>
							}}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Оператор <b>continue</b> в этой программе приводит к завершению внутреннего цикла со счетчиком j и переходу к очередной итерации внешнего цикла со счетчиком i. В процессе работы эта программа выводит
					следующие строки:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							0 <br>
							0 1 <br>
							0 2 4 <br>
							0 3 6 9 <br>
							0 4 8 12 16 <br>
							0 5 10 15 20 25 <br>
							0 6 12 18 24 30 36 <br>
							0 7 14 21 28 35 42 49 <br>
							0 8 16 24 32 40 48 56 64 <br>
							0 9 18 27 36 45 54 63 72 81							
						</div>
						</div>
					</div>					 
				</div>
				<hr>				
				<p>
					<h2 id="sec7">ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ НА JAVA</h2>
				</p>
				<p>
					<h5>7. КЛАССЫ</h5>
				</p>
				<p>
					Базовым элементом объектно-ориентированного программирования в языке Java является класс. В этой главе Вы научитесь создавать и расширять свои собственные классы, работать с экземплярами 
					этих классов. Напомним, что классы в Java не обязательно должны содержать метод <b>main</b>. Единственное назначение этого метода — указать интерпретатору Java, откуда надо начинать выполнение
					программы. Для того чтобы создать класс, достаточно иметь исходный файл, в котором будет присутствовать ключевое слово <b>class</b>, и вслед за ним — допустимый идентификатор и пара фигурных 
					скобок для его тела.
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							class Point { }					
						</div>
						</div>
					</div>					 
				</div>
				<p>
					ЗАМЕЧАНИЕ: Имя исходного файла Java должно соответствовать имени хранящегося в нем класса. Регистр букв важен и в имени класса, и в имени файла.
				</p>
				<p>
					<b>Класс</b> — это шаблон для создания объекта. Класс определяет структуру объекта и его <b>методы</b>, образующие функциональный интерфейс. В процессе выполнения Java-программы система использует определения 
					классов для создания представителей классов. Представители являются реальными <b>объектами</b>. Термины «представитель», «экземпляр» и «объект» взаимозаменяемы.
				</p>
				<div class="row">
					<div class="col-md-12">
						<div class="panel panel-default">
						<div class="panel-heading"><h4>Ниже приведена общая форма определения класса:</h4></div>
						<div class="panel-body">class имя_класса extends имя_суперкласса { <br>
												type переменная1_объекта: <br>
												type переменная2_объекта: <br>
												type переменнаяN_объекта: <br>
												type имяметода1(список_параметров) { <br>
												тело метода; <br>
												} 	<br>
												type имяметода2(список_параметров) { <br>
												тело метода; <br>
												} <br>
												type имя методаM(список_параметров) { <br>
												тело метода; <br>
												} <br>
												}
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Ключевое слово extends указывает на то, что «<b>имя класса</b>» — это подкласс класса «<b>имя_суперкласса</b>». Во главе классовой иерархии Java стоит единственный ее встроенный класс — Object. Если вы хотите создать подкласс 
					непосредственно этого класса, ключевое слово extends и следующее за ним имя суперкласса можно опустить — транслятор включит их в ваше определение автоматически. Примером может служить класс Point, приведенный выше.
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							class Point { }							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					ЗАМЕЧАНИЕ: Имя исходного файла Java должно соответствовать имени хранящегося в нем класса. Регистр букв важен и в имени класса, и в имени файла.
				</p>
				<p>
					<b>Класс</b> — это шаблон для создания объекта. Класс определяет структуру объекта и его <b>методы</b>, образующие функциональный интерфейс. В процессе выполнения Java-программы система использует определения классов для создания представителей 
					классов. Представители являются реальными <b>объектами</b>. Термины «представитель», «экземпляр» и «объект» взаимозаменяемы.
				</p>
				<div class="row">
					<div class="col-md-12">
						<div class="panel panel-default">
						<div class="panel-heading"><h4>Ниже приведена общая форма определения класса:</h4></div>
						<div class="panel-body">class имя_класса extends имя_суперкласса { <br>
												type переменная1_объекта: <br>
												type переменная2_объекта: <br>
												type переменнаяN_объекта: <br>
												type имяметода1(список_параметров) { <br>
												тело метода; <br>
												} <br>
												type имяметода2(список_параметров) { <br>
												тело метода; <br>
												} <br>
												type имя методаM(список_параметров) { <br>
												тело метода; <br>
												} <br>
												}
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Ключевое слово extends указывает на то, что «<b>имя класса</b>» — это подкласс класса «<b>имя_суперкласса</b>». Во главе классовой иерархии Java стоит единственный ее встроенный класс — Object. Если вы хотите создать подкласс непосредственно
					этого класса, ключевое слово extends и следующее за ним имя суперкласса можно опустить — транслятор включит их в ваше определение автоматически. Примером может служить класс Point, приведенный выше.
				</p>
				<p>
					<h2>7.1. Переменные класса</h2>
				</p>
				<p>
					Данные инкапсулируются в класс путем объявления переменных между открывающей и закрывающей фигурными скобками, выделяющими в определении класса его тело. Эти переменные объявляются точно так же, как объявлялись локальные переменные в предыдущих 
					примерах. Единственное отличие состоит в том, что их надо объявлять вне методов, в том числе вне метода <b>main</b>. Ниже приведен фрагмент кода, в котором объявлен класс Point с двумя переменными типа int.
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							class Point { <br>
							int x, у; <br>
							}							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В качестве типа для переменных объектов можно использовать как любой из простых типов, так и классовые типы.
				</p>
				<p>
					<h2>7.2. Оператор new</h2>
				</p>
				<p>
					Оператор <b>new</b> создает экземпляр указанного класса и возвращает ссылку на вновь созданный объект. Ниже приведен пример создания и присваивание переменной р экземпляра класса Point,
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							Point р = new Point();							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Вы можете создать несколько ссылок на один и тот же объект. Приведенная ниже программа создает два различных объекта класса Point и в каждый из них заносит свои собственные значения. Оператор «точка» используется для доступа к переменным и 
					методам объекта.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class TwoPoints { 
							public static void main(String args[]) { 
							Point p1 = new Point(); 
							Point p2 = new Point(); 
							p1.x= 10; 
							p1.у = 20; 
							p2.x = 42; 
							p2.y = 99; 
							System.out.println("x = " + p1.x + " у = " + p1.у); 
							System.out.println("x = " + p2.x + "y = " + p2.y); } 
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В этом примере использовался класс Point. Было создано два объекта этого класса. Переменным х и у объектов p1 и р2 присвоены различные значения. Таким образом, мы продемонстрировали, что переменные различных объектов независимы на самом деле.
					Ниже приведен результат, полученный при выполнении этой программы,
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							С:\> Java TwoPoints <br>
							х = 10 у = 20 <br>
							х = 42 у = 99							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>7.3. Объявление методов</h2>
				</p>
				<p>
					Методы - это подпрограммы, присоединенные к конкретным определениям классов. Они описываются внутри определения класса на том же уровне, что и переменные объектов. При объявлении метода задаются тип возвращаемого им результата и список параметров.
				</p>
				<div class="row">
					<div class="col-md-12">
						<div class="panel panel-default">
						<div class="panel-heading"><h4>Общая форма объявления метода такова:</h4></div>
						<div class="panel-body">тип имя_метода (список формальных параметров) {<br>
												тело метода; <br>
												}
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Тип результата, который должен возвращать метод, может быть любым, в том числе и типом void - в тех случаях, когда возвращать результат не требуется. Список формальных параметров - это последовательность пар тип- идентификатор, разделенных запятыми.
					Если у метода параметры отсутствуют, то после имени метода должны стоять пустые круглые скобки.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class Point { <br>
							int x,y; <br>
							void init(int a, int b) { <br>
							x = a; <br>
							y = b; <br>
							} <br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>7.4. Вызов метода</h2>
				</p>
				<p>
					В Java отсутствует возможность передачи параметров <b>по ссылке</b> на примитивный тип. В Java все параметры примитивных типов передаются <b>по значению</b>, а это означает, что у метода нет доступа к исходной переменной, использованной в качестве параметра. 
					Заметим, что все объекты передаются по ссылке, можно изменять содержимое того объекта, на который ссылается данная переменная.
				</p>
				<p>
					<h2>7.5. Скрытие переменных</h2>
				</p>
				<p>
					В языке Java не допускается использование в одной или во вложенных областях видимости двух локальных переменных с одинаковыми именами. Интересно отметить, что при этом не запрещается объявлять формальные параметры методов, чьи имена совпадают с именами
					переменных представителей. Давайте рассмотрим в качестве примера иную версию метода init, в которой формальным параметрам даны имена х и у, а для доступа к одноименным переменным текущего объекта используется ссылка <b>this</b>.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class Point { <br>
							int x, у; <br>
							void init(int x, int y) { <br>
							this.x = x; <br>
							this.y = у <br>
							} <br>
							} <br><br>

							
							class TwoPointsInit { <br>
							public static void main(String args[]) { <br>
							Point p1 = new Point(); <br>
							Point p2 = new Point(); <br>
							p1.init(10, 20); <br>
							p2.init(42, 99); <br>
							System.out.println("x = " + p1.x + " у = " + p1.y); <br>
							System.out.println(“x = " + p2.x + " у = " + p2.y); <br>
							} <br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>7.6. Конструкторы</h2>
				</p>
				<p>
					Инициализировать все переменные класса всякий раз, когда создается его очередной представитель, — довольно утомительное дело даже в том случае, когда в классе имеются функции, подобные методу init. Для этого в Java предусмотрены специальные методы, 
					называемые конструкторами. Конструктор — это метод класса, который инициализирует новый объект после его создания. Имя конструктора всегда <b>совпадает</b> с именем класса, в котором он расположен. У конструкторов нет типа возвращаемого результата - 
					никакого, даже void. Заменим метод init из предыдущего примера конструктором.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class Point { <br>
							int х, у; <br>
							Point(int х, int у) { <br>
							this.x = x; <br>
							this.y = y; <br>
							} <br>
							} <br><br>
							
							class PointCreate { <br>
							public static void main(String args[]) { <br>
							Point p = new Point(10,20); <br>
							System.out.println("x = " + p.x + " у = " + p.y); <br>
							}<br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>7.7. Совмещение методов</h2>
				</p>
				<p>
					Язык Java позволяет создавать несколько методов с одинаковыми именами, но с разными списками параметров. Такая техника называется совмещением методов (<b>methodoverloading</b>). В качестве примера приведена версия класса Point, в которой совмещение методов
					использовано для определения альтернативного конструктора, который инициализирует координаты х и у значениями по умолчанию (-1).
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class Point {  <br>
							int х, у;  <br>
							Point(int х, int у) {  <br>
							this.x = х;  <br>
							this.y = у;  <br>
							}  <br>
							Point() {  <br>
							х=-1;  <br>
							y=-1;  <br>
							}  <br>
							} <br> <br>
							
							
							class PointCreateAlt {  <br>
							public static void main(String args[]) {  <br>
							Point p = new Point();  <br>
							System.out.println("x = " + p.x + " у = " + p.y);  <br>
							}  <br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В этом примере объект класса Point создается не при вызове первого конструктора, как это было раньше, а с помощью второго конструктора без параметров. Результат работы этой программы:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							х = -1 <br>
							у = -1							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Решение о том, какой конструктор нужно вызвать в том или ином случае, принимается в соответствии с количеством и типом параметров, указанных в операторе new. Недопустимо объявлять
					в классе методы с одинаковыми именами и сигнатурами. В сигнатуре метода не учитываются имена формальных параметров, учитываются лишь их типы и количество.
				</p>
				<p>
					<h2>7.8. Ссылка this</h2>
				</p>
				<p>
					Очередной вариант класса Point показывает, как, используя this и совмещение методов, можно строить одни конструкторы на основе других.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class Point { <br>
							int х, у; <br>
							Point(int х, int у) { <br>
							this.x = x; <br>
							this.y = y; <br>
							} <br>
							Point() { <br>
							this(-l,-l); <br>
							} <br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В этом примере второй конструктор для завершения инициализации объекта обращается к первому конструктору.
				</p>
				<p>
					Методы, использующие совмещение имен, не обязательно должны быть конструкторами. В следующем примере в класс Point добавлены два метода distance. Функция distance возвращает расстояние
					между двумя точками. Одному из совмещенных методов в качестве параметров передаются координаты точки х и у, другому же эта информация передается в виде параметра-объекта Point.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class Point { <br>
							int x, у; <br>
							Point(int x, int у) { <br>
							this.x = x; <br>
							this. y = y; <br>
							} <br>
							double distance(int x, int y) {<br> 
							int dx = this.x - x; <br>
							int dy = this.y - y; <br>
							return Math.sqrt(dx*dx + dy*dy);<br>
							} <br>
							double distance(Point p) { <br>
							return distance(p.x, p.y); <br>
							} <br>
							} <br><br>
							
							
							class PointDist { <br>
							public static void main(String args[]) { <br>
							Point p1 = new Point(0,0); <br>
							Point p2 = new Point(30,40); <br>
							System.out.println("p1 = " + p1.x + ", " + p1.y);<br>
							System.out.println("p2 = " + p2.x + " + p2.y); <br>
							System.out.println("p1.distance(p2) =” + p1.distance(p2)); <br>
							System.out.println("p1.distance(60, 80) = " + pl.distance(60, 80));<br>
							}<br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Обратите внимание на то, как во второй форме метода distance для получения результата вызывается его первая форма. Ниже приведен результат работы этой программы:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							p1 = 0,0 <br>
							р2 = 30,40 <br>
							p1.distance(p2) = 50.0 <br>
							pl.distance(60, 80) = 100.0							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>7.9. Наследование</h2>
				</p>
				<p>
					Основным фундаментальным свойством объектно-ориентированного подхода является наследование. Классы-потомки имеют возможность не только создавать свои собственные переменные и методы,
					но и наследовать переменные и методы классов-предков. Классы-потомки принято называть подклассами. Непосредственного предка данного класса называют его суперклассом. В очередном примере
					показано, как расширить класс Point таким образом, чтобы включить в него третью координату z.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class Point3D extends Point { <br>
							int z; <br>
							Point3D(int x, int y, int z) { <br>
							this.x = x; <br>
							this.y = y; <br>
							this.z = z; <br>
							} <br>
							Point3D() { <br>
							this(-1,-1,-1); <br>
							} <br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В этом примере ключевое слово <b>extends</b> используется для того, чтобы сообщить транслятору о намерении создать подкласс класса Point. Как видите, в этом классе не понадобилось объявлять
					переменные х и у, поскольку Point3D унаследовал их от своего суперкласса Point.
				</p>
				<p>
					<h2>7.10. Ссылка super</h2>
				</p>
				<p>
					В примере с классом Point3D частично повторялся код, уже имевшийся в суперклассе. Вспомните, как во втором конструкторе мы использовали <b>this</b> для вызова первого конструктора того же класса.
					Аналогичным образом ключевое слово <b>super</b> позволяет обратиться непосредственно к конструктору суперкласса.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class Point3D extends Point { <br>
							int z; <br>
							Point3D(int x, int y, int z) { <br>
							super(x, у);           // Здесь мы вызываем конструктор суперкласса <br>
							this.z=z; <br>
							public static void main(String args[]) { <br>
							Point3D p = new Point3D(10, 20, 30); <br>
							System.out.println(“ x =” + p.x + ” у =” + p.y + " z =” + p.z); <br>
							} <br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Вот результат работы этой программы:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							x = 10 <br>
							y = 20 <br>
							z = 30							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>7.11. Замещение методов</h2>
				</p>
				<p>
					Новый подкласс Point3D класса Point наследует реализацию метода distance своего суперкласса. Проблема заключается в том, что в классе Point уже определена версия метода distance(int х, int у), 
					которая возвращает обычное расстояние между точками на плоскости. Мы должны <b>заместить</b> (override) это определение метода новым, пригодным для случая трехмерного пространства. В следующем примере 
					проиллюстрировано и <b>совмещение</b> (overloading), и <b>замещение</b> (overriding) метода distance.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class Point { <br>
							int x, у; <br>
							Point(int x, int у) { <br>
							this.x = x; <br>
							this.y = y; <br>
							} <br>
							double distance(int x, int y) { <br>
							int dx = this.x – x; <br>
							int dy = this.y - y: <br>
							return Math,sqrt(dx*dx + dy*dy); <br>
							} <br>
							double distance(Point p) { <br>
							return distance(p.x, p.y); <br>
							} <br>
							} <br><br>
							
							
							class Point3D extends Point { <br>
							int z; <br>
							Point3D(int x, int y, int z) { <br>
							super(x, y); <br>
							this.z = z; <br>
							} <br>
							double distance(int x, int y, int z) { <br>
							int dx = this.x - x; <br>
							int dy = this.y - y; <br>
							int dz = this.z - z; <br>
							return Math.sqrt(dx*dx + dy*dy + dz*dz); <br>
							} <br>
							double distance(Point3D other) { <br>
							return distance(other.x, other.y, other.z); <br>
							} <br>
							double distance(int x, int y) { <br>
							double dx = (this.x / z) - x; double dy = (this.y / z) - y; <br>
							return Math.sqrt(dx*dx + dy*dy); <br>
							} <br>
							} <br><br>
							
							
							class Point3DDist { <br>
							public static void main(String args[]) { <br>
							Point3D p1 = new Point3D(30,40,10); <br>
							Point3D p2 = new Point3D(0,0,0); <br>
							Point p = new Point(4,6); <br>
							System.out.println("p1 = " + p1.x + "," + p1.y + " + p1.z); <br>
							System.out.println("p2 = " + p2.x + ", " + p2.y + " + p2.z); <br>
							System.out.println("p = " + p.x + " + p.y); <br>
							System.out.println("p1.distance(p2) =” +p1.distance(p2)); <br>
							System.out.println("p1.distance(4,6) = " + p1.distance(4,6)); <br>
							System.out.println("p1.distance(p) =” + p1.distance(p)); <br>
							} <br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Результат работы этой программы:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							p1 =30,40,10 <br>
							р2 = 0,0,0 <br>
							р = 4,6 <br>
							p1.distance(p2) = 50.9902 <br>
							pl.distance(4,6) = 2.23607 <br>
							p1.distance(p) = 2.23607 					
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Обратите внимание — мы получили ожидаемое расстояние между трехмерными точками и между парой двумерных точек. В примере используется механизм, который называется динамическим назначением методов (dynamic
					method dispatch).
				</p>
				<p>
					<h2>7.12. Динамическое назначение методов</h2>
				</p>
				<p>
					Давайте в качестве примера рассмотрим два класса, у которых имеют простое родство подкласс/суперкласс, причем единственный метод суперкласса замещен в подклассе.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class А { <br>
							void callme() { <br>
							System.out.println("Вызван callme метод класса А"); <br>
							} <br>
							} <br><br>
							
							class В extends А { <br>
							void callme() { <br>
							System.out.println("Вызван callme метод класса В"); <br>
							} <br>
							} <br><br>
							
							class Dispatch { <br>
							public static void main(String args[]) { <br>
							A a = new B(); <br>
							a.callme(); <br>
							} <br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Обратите внимание — внутри метода main мы объявили переменную «а» класса А и проинициализировали ее ссылкой на объект класса В. В следующей строке мы вызвали метод callme. При этом транслятор проверил 
					наличие метода callme у класса А, а исполняющая система, увидев, что на самом деле в переменной хранится представитель класса В, вызвала не метод класса A, a callme класса В. Ниже приведен результат
					работы этой программы:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							Вызван callme метод класса В							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Рассмотренная форма динамического полиморфизма времени выполнения представляет собой один из наиболее мощных механизмов объектно-ориентированного программирования, позволяющих писать надежный,
					многократно используемый код.
				</p>
				<p>
					<h2>7.13. Директива final</h2>
				</p>
				<p>
					Все методы и переменные объектов могут быть замещены по умолчанию. Если же вы хотите объявить, что подклассы не имеют права замещать какие- либо переменные и методы вашего класса, вам нужно объявить
					их как final: final int FILE NEW = 1;
				<p/>
				<p>
					По общепринятому соглашению при выборе имен переменных типа final используются только символы верхнего регистра. Использование final-методов порой приводит к выигрышу в скорости выполнения кода — 
					поскольку они не могут быть замещены, транслятору ничто не мешает заменять их вызовы встроенным (in-line) кодом (байт-код копируется непосредственно в код вызывающего метода).
				</p>
				<p>
					<h5>7.14. Деструкторы</h5>
				</p>
				<p>
					В Java существует возможность объявлять методы с именем finalize. Методы finalize - это деструкторы - методы, которые уничтожают объект. Исполняющая среда Java будет вызывать его каждый раз, когда 
					сборщик мусора соберется уничтожить объект этого класса.
				</p>
				<p>
					<h5>7.15. Статические методы</h5>
				</p>
				<p>
					Иногда требуется создать метод, который можно было бы использовать вне контекста какого-либо объекта его класса. Так же, как в случае main, все, что требуется для создания такого метода — указать
					при его объявлении модификатор типа static. Статические методы могут непосредственно обращаться только к другим статическим методам, в них ни в каком виде не допускается использование ссылок <b>this</b>
					и <b>super</b>. Переменные также могут иметь тип static, они подобны глобальным переменным, то есть доступны из любого места кода. Внутри статических методов недопустимы ссылки на переменные представителей. 
					Ниже приведен пример класса, у которого есть статические переменные, статический метод и статический блок инициализации.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class Static { <br>
							static int а = 3; <br>
							static int  b; <br>
							static void method(int x) { <br>
							System.out.println("x =” + x); <br>
							System.out.println("a =” + a); <br>
							System.out.println("b = " + b); <br>
							} <br>
							static { <br>
							System.out.println("Статический блок инициализации"); <br>
							b = а * 4; <br>
							} <br>
							public static void main(String args[]) { <br>
							method(42); <br>
							} <br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					Результат запуска этой программы:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							х = 42 <br>
							а = 3 <br>
							b = 12							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В следующем примере мы создали класс со статическим методом и несколькими статическими переменными. Второй класс может вызывать статический метод по имени и ссылаться на статические переменные непосредственно
					через имя класса.
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							class StaticClass { <br>
							static int a = 42; <br>
							static int b = 99; <br>
							static void callme() {<br>
							System.out.println("a =” + a); <br>
							} <br>
							} <br>
							class StaticByName { <br>
							public static void main(String args[]) { <br>
							StaticClass.callme(); <br>
							System.out.println("b =” + StaticClass.b); <br>
							} <br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					А вот и результат запуска этой программы:
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							а = 42 <br>
							b = 99							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					<h2>7.16. Абстрактные классы</h2>
				</p>
				<p>
					Бывают ситуации, когда нужно определить класс, в котором задана структура какой-либо абстракции, но полная реализация всех методов отсутствует. В таких случаях вы можете с помощью модификатора типа <b>abstract</b> 
					объявить, что некоторые из методов обязательно должны быть замещены в подклассах. Любой класс, содержащий методы <b>abstract</b> , также должен быть объявлен как <b>abstract</b> . Поскольку у таких классов отсутствует полная 
					реализация, их представителей нельзя создавать с помощью оператора <b>new</b>. Кроме того, нельзя объявлять абстрактными конструкторы и статические методы. Любой подкласс абстрактного класса либо обязан предоставить
					реализацию всех абстрактных методов своего суперкласса, либо сам должен быть объявлен абстрактным,
				</p>
				<div class="row">
					<div class="col-md-8">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							<b>
							abstract class А <br>
							{ <br>
							abstract void callme(); <br>
							void metoo() { <br>
							System.out.println("Вызван metoo метод класса A"); <br>
							} <br>
							} <br><br>
							
							class В extends A { <br>
							void callme() { <br>
							System.out.println("Вызван callme метод класса В"); <br>
							} <br>
							} <br><br>
							
							class Abstract { <br>
							public static void main(String args[]) { <br>
							A a = new B(); <br>
							a.callme(); <br>
							a.metoo(); <br>
							} <br>
							}
							</b> 							
						</div>
						</div>
					</div>					 
				</div>
				<p>
					В нашем примере для вызова реализованного в подклассе класса А метода callme и реализованного в классе А метода metoo используется динамическое назначение методов, которое мы обсуждали раньше,
				</p>
				<div class="row">
					<div class="col-md-5">
						<div class="panel panel-default">				
						<div class="panel-body text-justify">							
							Вызван callme метод класса В <br>
							Вызван metoo метод класса А							
						</div>
						</div>
					</div>					 
				</div>	
				
				<hr>
					<h4>Поздравляю! Если Вы читаете это, то наверняка прошли этот электронный учебник по основам программирования на языке Java. Теперь у Вас есть возможность проверить полученные знания, выполнив задания предложенного теста. Удачи!
					<a href="test.html">Начать тест</a>
					</h4>
				<hr>

				</div><!--/right-->
			</div><!--/row-->
		</div><!--/container-->
	</body>
	<script>
			/* activate sidebar */
			$('#sidebar').affix({
				offset: {
					top: 235
				}
			});

			/* activate scrollspy menu */
			var $body   = $(document.body);
			var navHeight = $('.navbar').outerHeight(true) + 10;

			$body.scrollspy({
				target: '#leftCol',
				offset: navHeight				
			});

			/* smooth scrolling sections */
			$('a[href*=#]:not([href=#])').click(function() {
				if (location.pathname.replace(/^\//,'') == this.pathname.replace(/^\//,'') && location.hostname == this.hostname) {
					var target = $(this.hash);
					target = target.length ? target : $('[name=' + this.hash.slice(1) +']');
					if (target.length) {
						$('html,body').animate({
							scrollTop: target.offset().top - 50
						}, 1000);
					return false;
					}
				}
			});			
			
		</script>
</html>

